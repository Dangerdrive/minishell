commit 26cad520b552b65126e433bd0955f7390a353fb9
Author: Dangerdrive <felippealencar@gmail.com>
Date:   Mon Apr 22 22:39:49 2024 -0300

    redirects are functional (except heredoc)
    
    Execution is functional for one command (no pipes)
    
    $? expansion is not functional.
    Co-authored-by: Graziela Antunes <sagraziela@users.noreply.github.com>

diff --git a/.vscode/settings.json b/.vscode/settings.json
index ec4ba58..b935eb8 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -57,6 +57,7 @@
   "C_Cpp_Runner.useLinkTimeOptimization": false,
   "C_Cpp_Runner.msvcSecureNoWarnings": false,
   "files.associations": {
-    "numbers": "c"
+    "numbers": "c",
+    "*.gitignore": "cpp"
   }
 }
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 28d9884..1d61e14 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,6 @@
 # Name of the executable
 NAME = minishell
+NAME_BONUS = minishell_bonus
 
 # Compilation flags
 CFLAGS = -Wall -Wextra -Werror -g
@@ -31,19 +32,21 @@ SRC = 	./src/builtins/cd.c \
 		./src/lexer/lexer_utils.c \
 		./src/expand/expander.c \
 		./src/expand/expander_utils.c \
+		./src/expand/heredoc_expander.c \
 		./src/signals/signals.c \
 		./src/main/exec.c \
 		./src/main/exec_utils.c \
-		./src/main/heredoc_expander.c \
 		./src/main/main.c \
 		./src/main/main_utils.c \
-		./src/main/redir.c
+		./src/redirections/handle_redir.c \
+		./src/redirections/redir.c \
+		./src/redirections/redir_utils.c
 
 # Objects
 OBJ_PATH = src/build/
 OBJ = $(addprefix $(OBJ_PATH), $(notdir $(SRC:.c=.o)))
-# OBJ_PATH_BONUS = ./build_bonus/
-# OBJ_BONUS = $(addprefix $(OBJ_PATH_BONUS), $(notdir $(SRC_BONUS:.c=.o)))
+OBJ_PATH_BONUS = ./build_bonus/
+OBJ_BONUS = $(addprefix $(OBJ_PATH_BONUS), $(notdir $(SRC_BONUS:.c=.o)))
 
 # Color codes of output on terminal
 GREEN = \e[1;32m
@@ -72,6 +75,18 @@ run: all
 	@echo "Running the program..."
 	./minishell
 
+bonus: $(NAME_BONUS)
+
+# Target to build the bonus part
+$(NAME_BONUS): $(OBJ_BONUS) $(LIBFT) $(FTPRINTF)
+# 	@cp $(LIBFT) $(NAME_BONUS)
+# 	$(CC) $(OBJ) $(LIBFT) -L$(PATH_LIBFT) -o $(NAME_BONUS)
+	@$(CC) $(CFLAGS) $(OBJ) -o $@ -L$(FTPRINTF_PATH) -lftprintf -L$(LIBFT_PATH) -lft -L ../../../../usr/include -lreadline
+#	@$(CC) $(CFLAGS) $(OBJ) -o $@ -L$(FTPRINTF_PATH) -lftprintf -L$(LIBFT_PATH) -lft
+	@echo "$(GREEN)--------------------------------------------------$(END)"
+	@echo "$(GREEN)The [$(CYAN)MINI-SHELL$(GREEN)] has been compiled! üêöüåä$(END)"
+	@echo "$(GREEN)--------------------------------------------------$(END)"
+
 # Builds dependencies
 $(LIBFT):
 	@make -C $(LIBFT_PATH)
@@ -81,6 +96,12 @@ $(FTPRINTF):
 # Builds mandatory object files
 $(OBJ_PATH)%.o: src/**/%.c
 	@mkdir -p $(OBJ_PATH)
+	@mkdir -p .tmp/
+	$(CC) -c $(CFLAGS) $< -o $@ $(INCLUDES)
+
+# Builds bonus object files
+$(OBJ_PATH_BONUS)%.o: src/**/%.c
+	@mkdir -p $(OBJ_PATH_BONUS)
 	$(CC) -c $(CFLAGS) $< -o $@ $(INCLUDES)
 
 # Cleans object files and dependencies
diff --git a/includes/macros.h b/includes/macros.h
index 6b69aec..c9caf29 100644
--- a/includes/macros.h
+++ b/includes/macros.h
@@ -16,13 +16,15 @@
 # define SPECIAL_CHAR "special char"
 # define STRING_STRONG "string strong"
 # define STRING_STD "string standard"
+# define IN 0
+# define OUT 1
 
 //colors
 # define RED     		"\033[1;31m"
-# define GREEN   		"\033[1;32m"
-# define YELLOW 		"\033[1;33m"
-# define BLUE   	 	"\033[1;34m"
-# define MAGENTA    	"\033[1;35m"
+# define GREEN   		"\033[1;32m" // \e[1;32m
+# define YELLOW 		"\033[1;33m" // \e[1;33m
+# define BLUE   	 	"\033[1;34m" // \e[1;34m
+# define MAGENTA    	"\033[1;35m" // \e[1;35m
 # define CYAN    		"\033[1;36m"
 # define WHITE    		"\033[1;37m"
 # define END   			"\033[0m"
diff --git a/includes/minishell.h b/includes/minishell.h
index 6a2fd95..2f09559 100644
--- a/includes/minishell.h
+++ b/includes/minishell.h
@@ -91,12 +91,23 @@ void		interrupt_handler(int signal);
 void		define_prompt_signals(void);
 
 /*--------------exec---------------*/
-int			prepare_exec(t_global **data);
+int			handle_execution(t_global *data);
 int			hashsize(t_tkn *hashtable);
 char		**hash_to_args(t_tkn *node);
 char		*get_cmd(char *cmd, t_global *data);
 char		*get_cmd_path(char *cmd, char **paths);
-int 		parse_redirections(t_global **data, t_tkn **node);
+// int 		parse_redirections(t_global **data, t_tkn **node);
+
+/*------------redirections---------*/
+void		redirect_heredoc(int heredoc_number);
+int			redirect_input(char *input_redirect);
+int			redirect_output(char *output_redirect);
 void		expand_heredoc(t_global **data, char *line);
+void		redirect_fd(int fd_to_redirect, int fd_location);
+void		redirect_fds(int fd_in, int fd_out);
+void		close_all_fds(void);
+
+void		restore_original_fds(int original_fds[2]);
+int			handle_redirects(t_global *data, int ori_fds[2]);
 
 #endif
diff --git a/includes/minishell_bonus.h b/includes/minishell_bonus.h
new file mode 100644
index 0000000..e857b4d
--- /dev/null
+++ b/includes/minishell_bonus.h
@@ -0,0 +1,6 @@
+#ifndef MINISHELL_BONUS_H
+# define MINISHELL_BONUS_H
+
+# include "./minishell.h"
+
+#endif
diff --git a/includes/structs.h b/includes/structs.h
index 2acc65e..2051af9 100644
--- a/includes/structs.h
+++ b/includes/structs.h
@@ -35,8 +35,9 @@ typedef struct s_global
 	int				is_exec;
 	char			*input;
 	char			*output;
-	int				original_stdin;
-	int				original_stdout;
+	int				original_stdin;//
+	int				original_stdout;//
+	int				original_fds[2];
 	int				input_fd;
 	int				output_fd;
 	int				pipe[2];
diff --git a/src/main/heredoc_expander.c b/src/expand/heredoc_expander.c
similarity index 50%
rename from src/main/heredoc_expander.c
rename to src/expand/heredoc_expander.c
index 4c4ab24..58d2923 100644
--- a/src/main/heredoc_expander.c
+++ b/src/expand/heredoc_expander.c
@@ -1,21 +1,41 @@
 #include "../../includes/minishell.h"
 
-static void	handle_expand_fail(char **line, int i, int len, char **value)
+static void	handle_expand_fail(char **line, int i, int len)
 {
 	char	*new_line;
 	int		j;
 
 	j = 0;
 	new_line = ft_calloc((ft_strlen(*line) - len + 1), sizeof(char));
-	while (line[j])
+	while (*line[j])
 	{
-		new_line[j] = line[j];
+		new_line[j] = *line[j];
 		j++;
 		if (j == i)
-			j == len;
+			j += len;
 	}
 	free(*line);
-	line = ft_strdup(new_line);
+	*line = ft_strdup(new_line);
+	free(new_line);
+}
+
+static void	update_line(char **line, int i, int len, char **value)
+{
+	char	*new_line;
+	int		total_len;
+	int		val_len;
+	int		line_len;
+
+	line_len = ft_strlen(*line);
+	val_len = ft_strlen(*value);
+	total_len = line_len - len + val_len;
+	new_line = ft_calloc((total_len + 1), sizeof(char));
+	ft_strlcpy(new_line, *line, i);
+	ft_strlcpy((new_line + i), *value, val_len);
+	ft_strlcpy((new_line + i + val_len), (*line + i + len), (line_len - i - len));
+	free(*line);
+	free(*value);
+	*line = ft_strdup(new_line);
 	free(new_line);
 }
 
@@ -35,25 +55,22 @@ static int	get_var_value(t_global **data, char **line, int i)
 	}
 	value = search_value(data, line, i, len);
 	if (!value)
-		handle_expand_fail(line, i, len, value); // troca a var por "string vazia"
-	// else
-	// 	update_line(*line, i + len, len, &value);
+		handle_expand_fail(line, i, len);
+	else
+		update_line(line, i, len, &value);
 	return (1);
 }
 
 void	expand_heredoc(t_global **data, char *line)
 {
 	int		i;
-	//int		result;
 
 	i = 0;
-	//result = 0;
 	while (line[i] != '\0')
 	{
 		if (line[i] == '$')
 		{
 			i++;
-			//result =
 			get_var_value(data, &line, i);
 			break ;
 		}
diff --git a/src/main/exec.bak2 b/src/main/exec.bak2
new file mode 100644
index 0000000..b29939f
--- /dev/null
+++ b/src/main/exec.bak2
@@ -0,0 +1,449 @@
+#include "../../includes/minishell.h"
+
+// /**
+//  * Closes all file descriptors used in the pipex process.
+//  *
+//  * This function is responsible for closing the input and output file
+//  * descriptors, as well as all pipe file descriptors associated with the pipex
+//  * process. It checks if the input and output file descriptors are valid (not
+//  * equal to -1) before attempting to close them. The function then calls
+//  * `close_pipe_fds` to close all pipe file descriptors.
+//  *
+//  * @param[in,out] data Pointer to a t_data structure that contains the file
+//  *					 descriptors for input, output, and pipes.
+//  */
+// void	close_fds(t_global *data)
+//
+//{
+// 	int i;
+
+// 	if (data->input_fd != -1)
+// 		close(data->input_fd);
+// 	if (data->output_fd != -1)
+// 		close(data->output_fd);
+// 	i = 0;
+// 	while (i < (data->cmd_count - 1) * 2)
+// 	{
+// 		close(data->pipe[i]);
+// 		i++;
+// 	}
+// }
+
+// /**
+//  * Creates pipe file descriptors for inter-process communication in pipex.
+//  *
+//  * This function is responsible for setting up the necessary pipes for the pipex
+//  * program. It iterates through the required number of pipes, which is one less
+//  * than the command count, and creates each pipe. The file descriptors for each
+//  * pipe are stored in the 'pipe' field of the t_data structure. If a pipe
+//  * creation fails, the function prints an error message and exits the program
+//  * after performing cleanup.
+//  *
+//  * @param[in,out] data Pointer to a t_data structure containing the command
+//  *				     count and the array to store pipe file descriptors.
+//  */
+// static int	create_pipes(t_global *data)
+//
+//{
+// 	int	i;
+
+// 	i = 0;
+// 	while (i < hashsize(data->hashtable) - 1)
+// 	{
+// 		if (pipe(data->pipe + 2 * i) == -1)
+// 		{
+// 			ft_dprintf(2, "pipex: Could not create pipe: %s\n",
+// 				strerror(errno));
+// 			return (1);
+// 			//cleanup_n_exit(ERROR, data);
+// 		}
+// 		i++;
+// 	}
+// 	return (0);
+// }
+
+// /**
+//  * Initializes the t_data structure for the pipex program.
+//  *
+//  * This function initializes and sets up the t_data structure, which is used
+//  * throughout the pipex program. It stores command line arguments, environment
+//  * variables, and sets flags for 'here_doc' functionality. The function also
+//  * allocates memory for storing process IDs (pids) and pipe file descriptors,
+//  * handles input and output file setup, and creates the necessary pipes for
+//  * inter-process communication.
+//  *
+//  * @param[in] ac The count of command line arguments.
+//  * @param[in] av Array of command line argument strings.
+//  * @param[in] envp Array of environment variable strings.
+//  * @return An initialized t_data structure.
+//  */
+// t_data	init_data(int ac, char **av, char **envp)
+//
+// {
+// 	t_data	data;
+
+// 	data = initialize_data();
+
+// 	get_input_file(&data);
+// 	get_output_file(&data);
+// 	hashsize() = ac - 3 - data.heredoc_flag;
+// 	data.pids = malloc(sizeof(*data.pids) * hashsize());
+// 	if (!data.pids)
+// 	{
+// 		ft_dprintf(2, "pipex: PID error: %s\n", strerror(errno));
+// 		cleanup_n_exit(ERROR, &data);
+// 	}
+// 	data.pipe = malloc(sizeof(*data.pipe) * 2 * (hashsize() - 1));
+// 	if (!data.pipe)
+// 	{
+// 		ft_dprintf(2, "pipex: Pipe error: %s\n", strerror(errno));
+// 		cleanup_n_exit(ERROR, &data);
+// 	}
+// 	create_pipes(&data);
+// 	return (data);
+// }
+
+// /**
+//  * Redirects the standard input and output of a process.
+//  *
+//  * This function is responsible for redirecting the standard input (STDIN) and
+//  * standard output (STDOUT) of a process to specified file descriptors. It uses
+//  * the `dup2` system call to duplicate the given file descriptors to
+//  * STDIN_FILENO and STDOUT_FILENO. If either of the input or output file
+//  * descriptors is invalid (less than 0), the function will call
+//  * `cleanup_n_exit` to handle the situation. Similarly, if an error occurs
+//  * during the redirection process (e.g., `dup2` fails), the function will call
+//  * `exit_error` with an appropriate error message or code.
+//  *
+//  * @param[in] input The file descriptor to be set as the new standard input
+//  *                  (STDIN_FILENO).
+//  * @param[in] output The file descriptor to be set as the new standard output
+//  *                   (STDOUT_FILENO).
+//  * @param[in,out] data Pointer to a t_data structure for error handling and
+//  *                     other purposes.
+//  */
+// static void	redirect_io(int input, int output, t_data *data)
+//
+//{
+// 	if (input < 0 || output < 0)
+// 		cleanup_n_exit(ERROR, data);
+// 	if (dup2(input, STDIN_FILENO) == -1)
+// 		cleanup_n_exit(ERROR, data);
+// 	if (dup2(output, STDOUT_FILENO) == -1)
+// 		cleanup_n_exit(ERROR, data);
+// }
+
+// /**
+//  * Executes a child process in the Pipex pipeline.
+//  *
+//  * This function is responsible for configuring and executing a single command
+//  * within the pipeline. It redirects the standard input and output for the
+//  * child process based on its position in the pipeline:
+//  * - The first child uses the initial input file descriptor and the write-end
+//  *   of the first pipe.
+//  * - The last child uses the read-end of the last pipe and the final output
+//  *   file descriptor.
+//  * - Middle children use the read-end of their respective input pipe and the
+//  *   write-end of their respective output pipe. After setting up the
+//  *   redirection, the function closes any file descriptors that are no longer
+//  *   needed. It validates the command and its options and then executes the
+//  *   command using `execve`. If `execve` fails, it handles the error
+//  *   appropriately.
+//  *
+//  * @param[in,out] data Pointer to the `t_data` structure containing necessary
+//  *                     information for the child process, including file
+//  *                     descriptors, command options, and environment variables.
+//  */
+// static void	execute_child_process(t_data *data)
+//
+//{
+// 	if (data->child == 0)
+// 		redirect_io(data->input_fd, data->pipe[1], data);
+// 	else if (data->child == data->cmd_count - 1)
+// 		redirect_io(data->pipe[2 * data->child - 2], data->output_fd, data);
+// 	else
+// 		redirect_io(data->pipe[2 * data->child - 2],
+// 			data->pipe[2 * data->child + 1], data);
+// 	close_fds(data);
+// 	if (data->cmd_options == NULL || data->cmd_path == NULL)
+// 		cleanup_n_exit(ERROR, data);
+// 	if (execve(data->cmd_path, data->cmd_options, data->envp) == -1)
+// 	{
+// 		//cleanup_n_exit(ERROR, data);
+// 		ft_printf("pipex: %s: %s\n", data->cmd_options[0], strerror(errno));
+// 	}
+// }
+
+// /**
+//  * Manages the parent process in a pipeline of command executions.
+//  *
+//  * This function is responsible for closing unnecessary file descriptors and
+//  * waiting for child processes to complete their execution. It iterates through
+//  * the child processes, using `waitpid` to wait for each child to finish. The
+//  * function captures the exit status of the last child process in the pipeline,
+//  * which it returns as the overall exit code. It also performs cleanup by
+//  * freeing memory allocated for pipes and process IDs.
+//  *
+//  * @param[in,out] data Pointer to a t_data structure containing necessary
+//  *                     information, such as the number of commands, child
+//  *                     process IDs, and pipe file descriptors.
+//  *
+//  * @return The exit status code of the last child process in the pipeline. If no
+//  *         exit status is captured, the function defaults to returning 1.
+//  */
+// static int	execute_parent_process(t_data *data)
+//
+//{
+// 	pid_t	wpid;
+// 	int		status;
+// 	int		exit_code;
+
+// 	close_fds(data);
+// 	data->child--;
+// 	exit_code = 1;
+// 	while (data->child >= 0)
+// 	{
+// 		wpid = waitpid(data->pids[data->child], &status, 0);
+// 		if (wpid == data->pids[data->cmd_count - 1])
+// 		{
+// 			if ((data->child == (data->cmd_count - 1)) && WIFEXITED(status))
+// 				exit_code = WEXITSTATUS(status);
+// 		}
+// 		data->child--;
+// 	}
+// 	free(data->pipe);
+// 	free(data->pids);
+// 	return (exit_code);
+// }
+
+// /**
+//  * Manages the execution of a pipeline of commands.
+//  *
+//  * This function sets up a pipe and forks child processes for each command in the
+//  * pipeline. Each child process is responsible for executing one command. The
+//  * parent process waits for all child processes to complete and then collects
+//  * their exit codes. It handles the creation of pipes, parsing and execution of
+//  * commands, and manages potential errors in these processes. If a heredoc is
+//  * used, the function also ensures the removal of the temporary file after
+//  * execution.
+//  *
+//  * @param[in,out] data Pointer to a t_data structure containing necessary
+//  *                     information for pipelined command execution.
+//  *
+//  * @return The exit code of the last child process in the pipeline.
+//  */
+// static int	pipex(t_global *d)
+//
+//{
+// 	int		exit_code;
+// 	char	*command;
+
+// 	if (pipe(d->pipe) == -1)
+// 	{
+// 		ft_dprintf("minishell: %s\n", strerror(errno));
+// 		return (1);//ou outro erro
+// 	}
+// 	d->child = 0;
+// 	while (d->child < d->cmd_count)
+// 	{
+// 		d->cmd_path = get_cmd(d->cmd_options[0], d);
+// 		d->pids[d->child] = fork();
+// 		if (d->pids[d->child] == -1)
+// 			cleanup_n_exit(ft_printf("fork error: %s\n", strerror(errno)), d);
+// 		else if (d->pids[d->child] == 0)
+// 			execute_child_process(d);
+// 		free(d->cmd_path);
+// 		d->cmd_path = NULL;
+// 		free_array(d->cmd_options);
+// 		d->child++;
+// 	}
+// 	exit_code = execute_parent_process(d);
+// 	if (d->heredoc_flag == 1)
+// 		unlink(".heredoc.tmp");
+// 	return (exit_code);
+// }
+
+int	pipecount(t_global *data)
+{
+	int	result;
+
+	result = 0;
+	while (data->hashtable[result])
+	{
+		result++;
+	}
+	return (result - 1);
+}
+
+void	exec_command(t_global **data, int idx)
+{
+	char	**args;
+	char	*cmd;
+
+	parse_redirections(data, &(*data)->hashtable[idx]);
+	// if ((*data)->hashtable[idx]->content == NULL)
+	// 	exit(EXIT_SUCCESS);
+	args = hash_to_args((*data)->hashtable[idx]);
+	if (is_builtin(args[0]))
+		(*data)->ret = exec_builtin(args, hashsize((*data)->hashtable[idx]), *data);
+	else
+	{
+		(*data)->ret = 127; //arrumar valor de retorno para comandos que nao existem
+		cmd = get_cmd(args[0], *data);
+		if (cmd)
+			(*data)->ret = execve(cmd, args, (*data)->env); //consolidar env talvez
+		//perror("minishell: execve");
+	}
+	ft_strarr_free(args, ft_strarr_len(args));
+	//exit(EXIT_FAILURE);
+}
+
+void	create_pipes(int pipes[][2], int n)
+{
+	int	i;
+
+	i = 0;
+	while (i < n)
+	{
+		if (pipe(pipes[i]) == -1)
+		{
+			perror("minishell: pipe:");
+			exit(EXIT_FAILURE);
+		}
+		i++;
+	}
+}
+
+void	close_pipes(int pipes[][2], int n)
+{
+	int	i;
+
+	i = 0;
+	while (i < n)
+	{
+		close(pipes[i][0]);
+		close(pipes[i][1]);
+		i++;
+	}
+}
+
+void	fork_processes(t_global **data, int pipes[][2], int n)
+{
+	int	i;
+
+	i = 0;
+	while (i <= n)
+	{
+		(*data)->pid = fork();
+		if ((*data)->pid == -1)
+		{
+			perror("minishell: fork");
+			exit(EXIT_FAILURE);
+		}
+		else if ((*data)->pid == 0)
+		{
+			if (i > 0)
+				dup2(pipes[i - 1][0], STDIN_FILENO);
+			if (i < n)
+				dup2(pipes[i][1], STDOUT_FILENO);
+			close_pipes(pipes, n);
+			// if (parse_redirections((*data)->hashtable[i]) == 1) not included yet
+			// 	return;
+			if ((*data)->hashtable[i]->content == NULL)
+				return ;
+			exec_command(data, n); // TROQUEI O SEGUNDO ARG DE 'i' PARA 'n'
+		}
+		i++;
+	}
+}
+
+
+
+// int	exec(t_global *data)
+// {
+// 	int	n;
+// 	int	(*pipes)[2];
+
+// 	n = pipecount(data);
+// 	if (data->hashtable[0]->content == NULL && n == 0)
+// 		return (0);
+// 	pipes = malloc(n * sizeof(*pipes));
+// 	if (pipes == NULL)
+// 	{
+// 		perror("minishell: pipes: malloc failed");
+// 		return (-1);
+// 	}
+// 	create_pipes(pipes, n);
+// 	fork_processes(data, pipes, n);
+// 	close_pipes(pipes, n);
+// 	n = 2;
+// 	while (++n < 1024)
+// 		close(n);
+// 	while (wait(NULL) > 0)
+
+// 	free(pipes);
+// 	return (0);
+// }
+
+int exec(t_global **data)
+{
+	int n;
+	int(*pipes)[2];
+	int status;
+	pid_t pid;
+
+	n = pipecount(*data);
+	if ((*data)->hashtable[0]->content == NULL && n == 0)
+		return (0);
+	pipes = malloc(n * sizeof(*pipes));
+	if (pipes == NULL)
+	{
+		perror("minishell: pipes: malloc failed");
+		return (-1);
+	}
+	create_pipes(pipes, n);
+	fork_processes(data, pipes, n);
+	close_pipes(pipes, n);
+	n = 2;
+	while (++n < 1024)
+		close(n);
+	pid = waitpid(-1, &status, 0);
+	while (pid != -1)
+		pid = waitpid(-1, &status, 0);
+	free(pipes);
+	return (0);
+}
+
+int	handle_execution(t_global **data)
+{
+	int		ret;
+	char	**args;
+
+	args = NULL;
+	if ((*data)->hashtable[0]->content)
+		args = hash_to_args((*data)->hashtable[0]);
+	ret = 1;
+	// if (parse_redirections(data, &(*data)->hashtable[0]) == 1)
+	// 	return (1);
+	if (pipecount(*data) == 0 && args && args[0] && is_builtin(args[0]))
+		exec_builtin(args, hashsize((*data)->hashtable[0]), *data);
+	else if (pipecount(*data) > -1)
+		exec(data);
+	if ((*data)->hashtable[0]->content)
+		ft_strarr_free(args, ft_strarr_len(args));
+	// else
+	// 	return (exec(data, args));
+	return (ret);
+}
+
+// modificar wait para waitpid
+
+/*
+- check pipe behavior
+	- echo hello | tr 'a-z' 'A-Z' segfault
+	- does it git input from previous process
+- redirects
+	- create all files
+	- set fds
+	- reset fds/dup when needed
+*/
\ No newline at end of file
diff --git a/src/main/main_utils.c b/src/main/main_utils.c
index 13d0980..955c757 100644
--- a/src/main/main_utils.c
+++ b/src/main/main_utils.c
@@ -77,6 +77,7 @@ void	clean_stuff(t_global **data)
 		ft_strarr_free((*data)->exported, ft_strarr_len((*data)->exported));
 	free_hashtable(&(*data)->hashtable);
 	rl_clear_history();
+	close_all_fds();
 	ft_memdel((*data)->usr);
 	ft_memdel(*data);
 	*data = NULL;
diff --git a/src/main/redir.c b/src/main/redir.c
deleted file mode 100644
index 266eed1..0000000
--- a/src/main/redir.c
+++ /dev/null
@@ -1,165 +0,0 @@
-#include "../../includes/minishell.h"
-
-static char	*tmp_filename(int heredoc_number)
-{
-	char	filename[30];
-	char	*number_str;
-
-	ft_bzero(filename, 30);
-	number_str = ft_itoa(heredoc_number);
-	ft_strlcat(filename, "/tmp/heredoc", 30);
-	ft_strlcat(filename, number_str, 30);
-	free(number_str);
-	return (ft_strdup(filename));
-}
-
-void	redirect_heredoc(char *command, int heredoc_number)
-{
-	char	*filename;
-	int		tmp_file_fd;
-	char	*h_doc_pos;
-
-	filename = tmp_filename(heredoc_number);
-	tmp_file_fd = open(filename, O_RDONLY);
-	if (tmp_file_fd == -1)
-	{
-		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", filename, strerror(errno));
-		//print_perror_msg("open", filename);
-		free(filename);
-		return ;
-	}
-	free(filename);
-	redirect_fd(tmp_file_fd, STDIN_FILENO);
-	// h_doc_pos = get_redirect_position(command, heredoc_number);
-	//move_one_forward(h_doc_pos);
-	// ft_memmove(h_doc_pos, h_doc_pos + 1, ft_strlen(h_doc_pos + 1) + 1);
-}
-
-
-
-
-
-
-
-
-
-//-----------------------input-------------------------------|
-
-
-
-// int	is_name_delimeter(char c)
-// {
-// 	if (c == ' ' || c == '>' || c == '<' || c == '|' || c == '\t')
-// 		return (1);
-// 	return (0);
-// }
-
-
-
-// static int	get_name_end(char *name)
-// {
-// 	int	end;
-
-// 	end = 0;
-// 	while (name[end] && !is_name_delimeter(name[end]))
-// 	{
-// 		if (name[end] == '\'')
-// 		{
-// 			move_one_forward(&name[end]);
-// 			while (name[end] && name[end] != '\'')
-// 				end++;
-// 			move_one_forward(&name[end]);
-// 		}
-// 		else if (name[end] == '"')
-// 		{
-// 			move_one_forward(&name[end]);
-// 			while (name[end] && name[end] != '"')
-// 				end++;
-// 			move_one_forward(&name[end]);
-// 		}
-// 		else if (name[end] && !is_name_delimeter(name[end]))
-// 			end++;
-// 	}
-// 	return (end);
-// }
-
-// char	*get_label_name(char *redirect_str)
-// {
-// 	int		name_start;
-// 	int		name_end;
-// 	char	*name;
-// 	char	*remaining_cmd;
-
-// 	name_start = 0;
-// 	move_one_forward(redirect_str);
-// 	if (redirect_str[name_start] == '>')
-// 		move_one_forward(&redirect_str[name_start]);
-// 	while (redirect_str[name_start] == ' ' || redirect_str[name_start] == '\t')
-// 		name_start++;
-// 	name_end = get_name_end(&redirect_str[name_start]);
-// 	name = ft_substr(&redirect_str[name_start], 0, name_end);
-// 	remaining_cmd = &redirect_str[name_start + name_end];
-// 	ft_memmove(redirect_str, remaining_cmd, ft_strlen(remaining_cmd) + 2);
-// 	return (name);
-// }
-
-int	redirect_input(char *input_redirect)
-{
-	// char	*input_redirect;
-	char	*filename;
-	int		fd;
-
-	// input_redirect = get_redirect_position(command, '<');
-	// if (!input_redirect)
-	// 	return (SUCCESS);
-	//filename = get_label_name(input_redirect);
-	fd = open(input_redirect, O_RDONLY, FD_CLOEXEC);
-	if (fd == -1)
-	{
-		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", input_redirect, strerror(errno));
-		// free(input_redirect);
-		return (FAILED);
-	}
-	else
-		redirect_fd(fd, STDIN_FILENO);
-	// free(input_redirect);
-	return (SUCCESS);
-}
-
-
-//-----------------------output-------------------------------|
-
-int	redirect_output(char *output_redirect)
-{
-// 	char	*output_redirect;
-// 	char	*filename;
-	int		fd;
-	int		open_flags;
-
-	// output_redirect = get_redirect_position(command, '>');
-	// if (!output_redirect)
-	// 	return (1);
-
-	if (output_redirect[1] == '>')
-		fd = open(output_redirect, O_WRONLY | O_CREAT | O_APPEND, 0644);
-	else
-		fd = open(output_redirect, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-
-
-	// if (output_redirect[1] == '>')
-	// 	open_flags = O_WRONLY | O_CREAT | O_APPEND;
-	// else
-	// 	open_flags = O_WRONLY | O_CREAT | O_TRUNC;
-	// filename = get_label_name(output_redirect);
-	// fd = open(filename, open_flags, 0644);
-	if (fd == -1)
-	{
-		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", output_redirect, strerror(errno));
-		// free(filename);
-		return (0);
-	}
-	else
-		redirect_fd(fd, STDOUT_FILENO);
-	// free(filename);
-	return (1);
-}
diff --git a/src/main/redir_utils.c b/src/main/redir_utils.c
deleted file mode 100644
index 771ca39..0000000
--- a/src/main/redir_utils.c
+++ /dev/null
@@ -1,66 +0,0 @@
-#include "../../includes/minishell.h"
-
-void	move_one_forward(char *str)
-{
-	ft_memmove(str, str + 1, ft_strlen(str + 1) + 1);
-}
-
-char	*get_redirect_position(char *str, char redirect_char)
-{
-	while (*str)
-	{
-		if (*str == '\'')
-		{
-			str++;
-			while (*str != '\'')
-				str++;
-		}
-		if (*str == '"')
-		{
-			str++;
-			while (*str != '"')
-				str++;
-		}
-		if (*str == redirect_char)
-			return (str);
-		str++;
-	}
-	return (NULL);
-}
-
-char	get_next_redirect(char *str)
-{
-	while (*str)
-	{
-		if (*str == '\'')
-		{
-			str++;
-			while (*str != '\'')
-				str++;
-		}
-		if (*str == '"')
-		{
-			str++;
-			while (*str != '"')
-				str++;
-		}
-		if (*str == '<' || *str == '>' || *str < 0)
-			return (*str);
-		str++;
-	}
-	return (0);
-}
-
-void	redirect_fd(int fd_to_redirect, int fd_location)
-{
-	dup2(fd_to_redirect, fd_location);
-	close(fd_to_redirect);
-}
-
-void	redirect_fds(int fd_in, int fd_out)
-{
-	if (fd_in != STDIN_FILENO)
-		redirect_fd(fd_in, STDIN_FILENO);
-	if (fd_out != STDOUT_FILENO)
-		redirect_fd(fd_out, STDOUT_FILENO);
-}
diff --git a/src/redirections/handle_redir.c b/src/redirections/handle_redir.c
new file mode 100644
index 0000000..7a79416
--- /dev/null
+++ b/src/redirections/handle_redir.c
@@ -0,0 +1,64 @@
+#include "../../includes/minishell.h"
+
+void	save_original_fd_in(int original_fds[2])
+{
+	if (original_fds[IN] == -1)
+		original_fds[IN] = dup(STDIN_FILENO);
+}
+
+void	save_original_fd_out(int original_fds[2])
+{
+	if (original_fds[OUT] == -1)
+		original_fds[OUT] = dup(STDOUT_FILENO);
+}
+
+int	handle_input_redirect(char *command, int original_fds[2])
+{
+	save_original_fd_in(original_fds);
+	if (redirect_input(command) == 0)
+	{
+		redirect_fd(original_fds[IN], STDIN_FILENO);
+		return (0);
+	}
+	return (1);
+}
+
+int	handle_output_redirect(char *command, int original_fds[2])
+{
+	save_original_fd_out(original_fds);
+	if (redirect_output(command) == 0)
+	{
+		redirect_fd(original_fds[OUT], STDOUT_FILENO);
+		return (0);
+	}
+	return (1);
+}
+
+int	handle_redirects(t_global *data, int ori_fds[2])
+{
+	int		i;
+
+	i = 0;
+	ori_fds[IN] = -1;
+	ori_fds[OUT] = -1;
+	while (data->hashtable[0]->redir[i])
+	{
+		if (ft_strncmp(data->hashtable[0]->redir[i], "< ", 2) == 0)
+		{
+			if (!handle_input_redirect(data->hashtable[0]->redir[i], ori_fds))
+				return (0);
+		}
+		if (data->hashtable[0]->redir[i][0] == '>')
+		{
+			if (!handle_output_redirect(data->hashtable[0]->redir[i], ori_fds))
+				return (0);
+		}
+		if (ft_strncmp(data->hashtable[0]->redir[i], "<<", 2) == 0)
+		{
+			save_original_fd_in(ori_fds);
+			redirect_heredoc(i);
+		}
+		i++;
+	}
+	return (1);
+}
diff --git a/src/redirections/redir.c b/src/redirections/redir.c
new file mode 100644
index 0000000..14aa89a
--- /dev/null
+++ b/src/redirections/redir.c
@@ -0,0 +1,68 @@
+#include "../../includes/minishell.h"
+
+static char	*tmp_filename(int heredoc_number)
+{
+	char	filename[30];
+	char	*number_str;
+
+	ft_bzero(filename, 30);
+	number_str = ft_itoa(heredoc_number);
+	ft_strlcat(filename, "/tmp/heredoc", 30);
+	ft_strlcat(filename, number_str, 30);
+	free(number_str);
+	return (ft_strdup(filename));
+}
+
+void	redirect_heredoc(int heredoc_number)
+{
+	char	*filename;
+	int		tmp_file_fd;
+
+	filename = tmp_filename(heredoc_number);
+	tmp_file_fd = open(filename, O_RDONLY);
+	if (tmp_file_fd == -1)
+	{
+		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", filename, strerror(errno));
+		free(filename);
+		return ;
+	}
+	free(filename);
+	redirect_fd(tmp_file_fd, STDIN_FILENO);
+}
+
+int	redirect_input(char *input_redirect)
+{
+	int		fd;
+
+	fd = open(&input_redirect[2], O_RDONLY, FD_CLOEXEC);
+	if (fd == -1)
+	{
+		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", &input_redirect[2], strerror(errno));
+		// free(input_redirect);
+		return (0);
+	}
+	else
+		redirect_fd(fd, STDIN_FILENO);
+	// free(input_redirect);
+	return (1);
+}
+
+int	redirect_output(char *output_redirect)
+{
+	int		fd;
+
+	if (output_redirect[1] == '>')
+		fd = open(&output_redirect[2], O_WRONLY | O_CREAT | O_APPEND, 0644);
+	else
+		fd = open(&output_redirect[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
+	if (fd == -1)
+	{
+		ft_dprintf(STDERR_FILENO, "open: %s: %s\n", &output_redirect[2], strerror(errno));
+		// free(filename);
+		return (0);
+	}
+	else
+		redirect_fd(fd, STDOUT_FILENO);
+	// free(filename);
+	return (1);
+}
diff --git a/src/redirections/redir_utils.c b/src/redirections/redir_utils.c
new file mode 100644
index 0000000..8c3fa73
--- /dev/null
+++ b/src/redirections/redir_utils.c
@@ -0,0 +1,46 @@
+#include "../../includes/minishell.h"
+
+void	close_extra_fds(void)
+{
+	int	last_open_fd;
+
+	last_open_fd = open("/tmp/last_fd", O_RDWR | O_CREAT, 0666);
+	if (last_open_fd == -1)
+		ft_dprintf(STDERR_FILENO, "minishell: %s: %s\n", "/tmp/last_fd", strerror(errno));
+		// print_perror_msg("open", "/tmp/last_fd");
+	while (last_open_fd > STDERR_FILENO)
+	{
+		close(last_open_fd);
+		last_open_fd--;
+	}
+}
+
+void	close_all_fds(void)
+{
+	close_extra_fds();
+	close(STDIN_FILENO);
+	close(STDOUT_FILENO);
+	close(STDERR_FILENO);
+}
+
+void	redirect_fd(int fd_to_redirect, int fd_location)
+{
+	dup2(fd_to_redirect, fd_location);
+	close(fd_to_redirect);
+}
+
+void	redirect_fds(int fd_in, int fd_out)
+{
+	if (fd_in != STDIN_FILENO)
+		redirect_fd(fd_in, STDIN_FILENO);
+	if (fd_out != STDOUT_FILENO)
+		redirect_fd(fd_out, STDOUT_FILENO);
+}
+
+void	restore_original_fds(int original_fds[2])
+{
+	if (original_fds[IN] != -1)
+		redirect_fd(original_fds[IN], STDIN_FILENO);
+	if (original_fds[OUT] != -1)
+		redirect_fd(original_fds[OUT], STDOUT_FILENO);
+}
diff --git a/src/token/token.c b/src/token/token.c
index 18d188f..b8cdd9a 100644
--- a/src/token/token.c
+++ b/src/token/token.c
@@ -128,7 +128,7 @@ int	readline_and_handle_input(t_global **data)
 	{
 		input = parse(&(*data)->hashtable, data);
 		if (input == 1)
-			(*data)->ret = prepare_exec(data);
+			(*data)->ret = handle_execution(*data);
 		// 	prt_hashtable((*data)->hashtable);
 	}
 	return (1);
diff --git a/test2 b/test2
new file mode 100644
index 0000000..1fc3c2f
--- /dev/null
+++ b/test2
@@ -0,0 +1,32 @@
+allowed_functions.txt
+includes
+libs
+Makefile
+minishell
+minishell~87b77d2d35d6286299b76cd64c9bcc6588bb5ecb
+myredir
+project.yml
+readline.supp
+README.md
+src
+> test
+test
+test2
+testing.c
+tests
+allowed_functions.txt
+includes
+libs
+Makefile
+minishell
+minishell~87b77d2d35d6286299b76cd64c9bcc6588bb5ecb
+myredir
+project.yml
+readline.supp
+README.md
+src
+> test
+test
+test2
+testing.c
+tests
